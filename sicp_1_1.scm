(print "1.1 プログラムの要素-------------")
(print "  1.1.1 式\n")
;; 式の並びを括弧で囲んで手続きの作用を表現するような式 = 組み合わせ(combinations)
;; 左端の要素 = 演算子(operator)
;; 他の要素   = 被演算子(operands)
;; 組合せの値は, 演算子が指定する手続きを, 被演算子の値である引数(arguments)に作用させる
;; 基本的な式は組合せ(combinations)ではない？
;; 1や'hoge'など
(print (+ 1 10))
(print (* 2 2))

;; 左端に演算子(operator)があることで, 引数(arguments)を任意個とることができる
;; ネスト構造や複雑さに(原則として)制限はないので, 人が読みやすい形式(pretty print)で構造を明瞭化する
(print (+ 2 2 3 3))

(print (+ (* 3
             (+ (* 2 4)
                (+ 3 5)))
          (+ (- 10 7)
             6))
       )


(print "\n\n  1.1.2 名前と環境\n")
;; オブジェクトを値(value)とする変数(variable)を識別するのが名前である(変数識別子の事だと思う)
;; Schemeではdefineを使って名前をつける
(define size 2)
(print (* 5 size))

(define pi 3.14)
(define radius 10)
(print (* pi
          (* radius radius)
       ))
(define circumference (* 2 pi radius))
(print circumference)
;; 合成演算の結果を指すのにも名前を使う事ができる. これが最も簡単な抽象化の手段である.
;; 値と記号を対応づけて後続の処理で利用可能な状態にしておくためには,
;; 解釈系が値とオブジェクトの対を記憶しておく必要がある.
;; この記憶を環境(environment)という.
;; 本来計算は多くの異なる環境(environment)が存在するため,
;; より正確に表現するならばcircumferenceという変数は大域環境(global environment)にあるという.


(print "\n\n  1.1.3 組合せの評価\n")
;; 手続き的な考え方に注目する.
;; 組合せ(combinations)を評価するには次の事を行う ※あくまで以下の話は組合せの評価規則である
;; 1. 組合せ(combinations)の部分式を評価する
;; 2. 演算子(operator)を, 引数(arguments)に適応させる
(print (* (+ 2(* 4 6)
          (+ 3 5 7))
       ))
;; 上記の例が, (* 26 15) になるまで1. ~ 2.の評価を再帰的続ける.
;; この評価は木構造に表すと, 終端の節点から始まり, 上方へと流れていく.
;; 評価規則は「値が上方へ湧き出す」
;; この構造は木構造の溜め込み(tree accumulation)として知られる一般的処理の一例.
;; 組合せの評価規則の1.を再帰的に繰り返していくと, 評価する必要のない数字列, 文字列, 演算子, 変数のような
;; 組合せ(combinations)ではない「基本的式」への地点へと到る.
;; 「基本的な式」は次のように扱う.
;;
;; - 数字列の値は, その表す数値とする
;; - 基本演算子の値は, 対応する演算を実行する機械命令の列とする
;; - それ以外の名前の値は, その環境で名前と対応づけたオブジェクトとする
;;
;; +などの基本演算子は大域環境(global environment)に含まれていて, その値である機械命令の列に対応づけられていると想定すれば,
;; 第二第三の規則は特例と観ても良い.
;; 環境が異なれば, (+ x 1)の記号x（あるいは+)の値は変化する.
;; つまり「環境とは評価が行われる文脈を提供するものである」
;;
;; 上の評価規則は, 定義を扱わない.
;; (define x 3)は二つの引数(arguments)に作用させるものではない.
;; defineの目的はxに3を対応付ける事なので, 組合せ(combinations)ではない.
;;
;; このような一般評価規則の例外を「特殊形式(special forms)」という.
;; 特殊形式(special forms)はそれぞれ独自の評価規則を持つ.


(print "\n\n  1.1.4 合成手続き\n")
;; - 数と算術演算子は基本的データと手続きである(手続き=メソッド,処理みたいなイメージか？)
;; - 組合せの入れ子(ネスト構造)は演算を組み合わせる手段である
;; - 名前(変数識別子？)と値を対応づける定義は抽象化の最も簡単な手段である
;;
;; さらに強力な抽象化手段である手続き定義(procedure definitions)がある.
;; これによって合成演算に名前をつけておくことができる.
(define (square x) (* x x))
(print (square 2))

;; 手続き定義の一般的な形は:
;; (define (<name> <formal parameters>) <body>) である.
;; 名前<name>は, 環境(environment)でこの手続定義に対応づける名前である.
;; x^2 + y^2は以下のように表現できる.
(define x 3)
(define y 2)
(print (+ (square x) (square y)))

;; 引数として二つの数値を取り, それらの数値の二乗の和を作る手続き
(define (sum-of-squares a b)
  (+ (square a) (square b)))
(print (sum-of-squares 2 2))

;; このように一度作った手続き定義は, 他の手続き定義の合成素材としても利用可能である.
;; 合成手続きは基本的手続きと全く同様に扱う事ができる.
;; 基本的手続き = 大域環境(global environment)に最初から定義されている手続き？
;; 合成手続き   = 自分で環境(environment)に名前をつけて定義した手続き？


(print "\n\n  1.1.5 手続き作用の置換えモデル\n")
;; 合成手続きを評価する時も, 1.1.3で行った基本的手続きの評価規則と殆ど同じプロセスを踏む.(殆ど？)
;;
;; [1.1.3から引用]
;; 1. 組合せ(combinations)の部分式を評価する
;; 2. 演算子(operator)を, 引数(arguments)に適応させる
;;
;; 合成手続きにおいて作用のプロセスは以下となる.
;; 「合成手続きを引数に作用させるには, 各仮パラメータを対応する引数で取り替え, 手続きの本体を評価する」
;; このプロセスの流れを見てみよう
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(print (f 5)) ;; => 136

;; 上記を例にして評価のプロセスを追う.
(f 5)
(sum-of-squares (+ a 1) (* a 2)) ;; fの本体を取り出す.
(sum-of-squares (+ 5 1) (* 5 2)) ;; 仮パラメータであるaを引数5に置き換える.
(sum-of-squares 6 10)            ;; sum-of-squaresが作用させるべき引数を得るために, 被演算子(operands)を評価する.
                                 ;; その結果, sum-of-squaresは6と10に作用させることになる.
(+ (square 6) (square 10))       ;; sum-of-squaresの本体であるsquareの仮パラメータのxとyに置き換わる.
(+ (* 6 6) (* 10 10))            ;; squareの定義を使い, 基本的手続きに帰結する.
(+ 36 100)
(print 136)

;; 上記のプロセスを, 「手続き作用の置換えモデル(substitution model)」という.
;; これは手続き作用の「意味」を定めるモデルである. (意味 = 変数を環境ごとに設定されている値に決定すること？)
;;
;; しかしながら, 置換えは実際の解釈系の動きを述べるものではなく, 人間が手続き作用を考える時の手助けとなる考え方である.
;; 実際には仮パラメータの局所環境を使って実現している. (局所環境？大域環境の対比と考えるとlocal scopeと同義？)
;;
;; 実際の解釈系の精巧なモデルは後々でてくる.
;; 置換えモデルは, 評価プロセスを形式的に考える第一歩になる.
;; 可変データをもつ手続きを扱う場合, 置き換えモデルは破綻して, 手続き作用のより複雑なモデルで考えなければならない.
;; ※ 変数への再代入を許可することで, 純粋な置き換えモデルは破綻する

;; 【作用的順序と正規順序】
;; 前述の評価モデルだけではなく, 実際にその値が必要になるまで, 被演算子(operands)を評価しないものもある.
;; この評価モデルでは, 基本的演算子だけを持つ式が出てくるまで, パラメータへの被演算子(operands)の式の置換えを繰り返し, それから評価する.
(f 5)
(sum-of-squares (+ a 1) (* a 2))            ;; fの本体を取り出す.
(sum-of-squares (+ 5 1) (* 5 2))            ;; 仮パラメータであるaを引数5に置き換える.
(+ (square (+ 5 1)) (square (* 5 2)))       ;; sum-of-squaresの本体を取り出す.
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2))) ;; squareの本体を取り出す. ここでやっと基本的演算子だけを持つ状態になる.
(+ (* 6 6) (* 10 10))                       ;; 木構造の終端から評価
(+ 36 100)
(print 136)

;; つまり
;; この「完全に展開し, 簡約する」評価方法を正規順序の評価(normal-order evaluation),
;; 実際に解釈系が使っている「引数を評価し, 作用させる」評価方法を作用的順序の評価(applicative-order evaluation)と呼ぶ
;; 純粋な置換えモデルが成り立つ限り, 正規順序と作用的順序の結果は等しくなる.
;; 再代入などが出てくるとその限りではない？
;;
;; 解釈系が作用的順序を使用している理由:
;;   1. 正規順序だと(+ 5 1)が二回出てきていて, 非効率であること
;;   2. 置換えモデルが成り立たない場合に, 極めて複雑になる
